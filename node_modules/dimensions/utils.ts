import * as path from 'path';
import Packet from 'dimensions/packet';
import BufferReader from 'dimensions/packets/bufferreader';
import * as utf8 from 'utf8';

export interface BuffersPackets {
  bufferPacket: Buffer;
  packets: Packet[];
}

export function hex2a(hexx: string): string {
  let hex: string = hexx.toString(); //force conversion
  let str: string = '';
  for (let i: number = 0; i < hex.length; i += 2)
    str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  return str;
}

export function a2hex(str: string): string {
  let arr: string[] = [];
  for (var i = 0, l = str.length; i < l; i++) {
    let prehex: string = Number(str.charCodeAt(i)).toString(16);
    let hex: string = prehex.length === 1 ? `0${prehex}` : prehex;
    arr.push(hex);
  }

  let builtString: string = arr.join('');

  // Must have even number of hex digits
  if (builtString.length % 2 !== 0) {
    builtString = "0" + builtString;
  }
  return builtString;
}

export function str2Hex(str: string): Buffer {
  return new Buffer(str, 'hex');
}

export function hex2str(hex: Buffer): string {
  return hex.toString("hex");
}

export function getProperIP(ip: string): string {
  let IPFromRequest: string = ip;
  let indexOfColon: number = IPFromRequest.lastIndexOf(':');
  let IP: string = IPFromRequest.substring(indexOfColon + 1, IPFromRequest.length);
  return IP;
}

export function getPacketLengthFromData(hexStr: string): string {
  let prePacketLength: string = (hexStr.length / 2).toString(16);
  if (prePacketLength.length !== 4) {
    for (let j: number = prePacketLength.length; j < 4; j++) {
      prePacketLength = "0" + prePacketLength;
    }
  }

  // Assign hex packet length
  let packetLength: string = (prePacketLength.length / 2 + parseInt(prePacketLength, 16)).toString(16);

  // Ensure it takes up 4 hex digits
  if (packetLength.length !== 4) {
    for (let j: number = packetLength.length; j < 4; j++) {
      packetLength = "0" + packetLength;
    }
  }

  // Reverse byte order
  let firstByte: string = packetLength.substr(0, 2);
  let secondByte: string = packetLength.substr(2, 2);
  packetLength = secondByte + firstByte + packetLength.substr(4);

  return packetLength;
}

export function getPacketTypeFromHexString(buf: Buffer): number {
  return buf.readUInt8(2);
}

export function getPacketsFromHexString(buf: Buffer): BuffersPackets {
  const reader = new BufferReader(buf);
  let packets: Packet[] = [];
  let end: boolean = false;
  let length: number;
  let data: Buffer;
  let index: number = 0;
  let packetType: number;
  let bufferPacket: Buffer = new Buffer("");
  while (!end) {
    length = reader.readUInt16();

    if (length === 0) {
      end = true;
    } else {
      data = buf.slice(reader.head - 2, reader.head - 2 + length);
      reader.head += length - 2;
      if (reader.head > buf.length) {
        //console.log("Index [" + index + "] exceeds data length [" + str.length + "]");
        bufferPacket = data;
        end = true;
      } else {
        packetType = getPacketTypeFromHexString(data);
        packets.push({
          packetType: packetType,
          data: data
        });

        if (reader.head === buf.length) {
          end = true;
        }
      }
    }
  }

  return { bufferPacket: bufferPacket, packets: packets };
}

/* Ensures a hex string is an even number of hex digits */
export function getCorrectHex(hexString: string): string {
    if (hexString.length % 2 !== 0) {
      hexString = "0" + hexString;
    }

    return hexString;
}

export function _invalidateRequireCacheForFile(filePath: string, require: NodeRequire) {
  var realPath = path.resolve(filePath);
  delete require.cache[realPath];
}

export function requireNoCache(filePath: string, require) {
  _invalidateRequireCacheForFile(filePath, require);
  return require(filePath);
}

let MathEx = {
  getRandomInt: function (min, max) {
    return Math.floor(Math.random() * ((max + 1) - min)) + min;
  }
}


export function getPackedStringByteLen(str: string) {
  const strLen = a2hex(utf8.encode(str)).length / 2;
  if (str.length > 128) {
    return 2 + strLen;
  }

  return 1 + strLen;
}