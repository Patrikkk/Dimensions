import { a2hex, getCorrectHex } from 'dimensions/utils';
import * as utf8 from 'utf8';
import NetworkText from 'dimensions/packets/networktext';
import Writer from 'dimensions/packets/writer';

class BufferWriter implements Writer {
    protected _buffer: Buffer;
    protected _offset: number = 0;

    constructor(size: number) {
        this._buffer = Buffer.alloc(size);
    }

    public changeOffset(offset: number) {
        this._offset = offset;
    }

    public packInt16(int16: number) {
        this._buffer.writeInt16LE(int16, this._offset);
        this._offset += 2;
        return this;
    }

    public packUInt16(uint16: number) {
        this._buffer.writeUInt16LE(uint16, this._offset);
        this._offset += 2;
        return this;
    }

    public packInt32(int32: number) {
        this._buffer.writeInt32LE(int32, this._offset);
        this._offset += 4;
        return this;
    }

    public packUInt32(uint32: number) {
        this._buffer.writeUInt32LE(uint32, this._offset);
        this._offset += 4;
        return this;
    }

    public packUInt64(uint64: number) {
        this.packUInt32(uint64 >> 8);
        this.packUInt32(uint64 & 0x00ff);
        return this;
    }

    public packSingle(single: number) {
        this._buffer.writeFloatLE(single, this._offset);
        this._offset += 4;
        return this;
    }

    public packByte(byte: number) {
        if (byte < 0) byte = -byte;
        this._buffer.writeUInt8(byte, this._offset);
        this._offset += 1;
        return this;
    }

    public packBytes(bytes: number[]) {
        for (const byte of bytes) {
            this.packByte(byte);
        }

        return this;
    }

    public packHex(hex: string) {
        const buf = Buffer.from(hex, "hex");
        buf.copy(this._buffer, this._offset, 0);
        this._offset += buf.length;
        return this;
    }

    public packBuffer(buffer: Buffer) {
        buffer.copy(this._buffer, this._offset, 0);
        this._offset += buffer.length;
        return this;
    }

    public packString(str: string) {
        let strHex: string = a2hex(utf8.encode(str));
        let sizeOfString: number = strHex.length / 2;
        let strLengthInHex: string;

        /* Sizes >= 128 require an extra byte (and maybe more but I doubt
            we will get bigger than strings of length 255*128) */
        if (sizeOfString >= 128) {
            strLengthInHex = getCorrectHex(((sizeOfString % 128) + 128).toString(16)) + getCorrectHex(Math.floor(sizeOfString / 128).toString(16));
        } else {
            strLengthInHex = getCorrectHex((strHex.length / 2).toString(16));
        }

        this.packHex(strLengthInHex)
        this.packHex(strHex);
        return this;
    }

    public packColor(color: {R:number;G:number;B:number}) {
        this.packByte(color.R);
        this.packByte(color.G);
        this.packByte(color.B);
        return this;
    }

    public packNetworkText(networkText: NetworkText) {
        this.packByte(networkText.mode);
        this.packString(networkText.text);
        return this;
    }

    public get data() {
        return this._buffer;
    }

    public get slicedData() {
        return this._buffer.slice(0, this._offset);
    }
}

export default BufferWriter;